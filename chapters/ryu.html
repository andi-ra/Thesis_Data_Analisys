
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SDN e controller &#8212; Tesi Andi Dulla</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Ottimizzazione del traffico" href="optimization.html" />
    <link rel="prev" title="Reti di sensori" href="sensor.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Tesi Andi Dulla</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   SDN forming per mobile IoT
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Strumenti
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="sensor.html">
   Reti di sensori
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   SDN e controller
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Teoria
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="optimization.html">
   Ottimizzazione del traffico
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stable.html">
   Distribuzioni stabili
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Risultati simulazione
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="analisi_dati_rete_BOBI.html">
   Applicazione di controllo distribuito
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="main_pipeline.html">
   Aumento della robustezza della rete
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="frank-wolfe.html">
   Allocazione ottima delle risorse
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../_sources/chapters/ryu.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/chapters/ryu.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/executablebooks/jupyter-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fchapters/ryu.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/chapters/ryu.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#netapp-e-controller">
   NetApp e controller
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>SDN e controller</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#netapp-e-controller">
   NetApp e controller
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="sdn-e-controller">
<h1>SDN e controller<a class="headerlink" href="#sdn-e-controller" title="Permalink to this headline">¶</a></h1>
<p>Con SDN ci riferiamo al nuovo approccio adottato negli ultimi anni dal networking. Al cuore di questa nuova modalità vi
è il paradigma match-action. Il paradigma match-action rappresenta un grosso cambio di mentalità e soprattutto di
tecnologia, in quanto la rete fa molto più affidamento al software. Fino alla prima metà del decennio scorso (e tuttora
in molti casi “enterprise”) la rete di telecomunicazioni era suddivisa in parte di <em>accesso</em> e parte di <em>trasporto</em>. La
porzione di accesso doveva (definita in grgo l’ultimo miglio) connetteva l’utente finale con i dispositivi del centro
della rete. Questa porzione periferica doveva essere economica per permettere una capillare penetrazione nel territorio,
poiché i clienti finali sono distribuiti sul territorio. La parte di trasporto è quella più vicina al concetto classico
di rete. Un sistema di apparati che cooperano al fine di connettere un punto A ad un punto B attraverso i loro flussi
informativi. In una concezione di questo tipo dell’infrastruttura totale di telecomunicazione, il software risiedeva in
due punti molto diversi fra loro per la funzione che avevano. Questi due punti sono:</p>
<ol class="simple">
<li><p>nel dispositivo router che calcola le rotte fra A e B e di queste ne sceglie la migliore</p></li>
<li><p>nel sistema di gestione e raccolta allarmi centrale dell’operatore (per la fatturazione, il troubleshooting…)</p></li>
</ol>
<div class="margin sidebar">
<p class="sidebar-title">NOC</p>
<p>Network operation center, è il luogo (o i luoghi) da cui l’operatore può elaborare gli alert e problemi della rete da
remoto e fare troubleshooting per risolvere problemi tecnici e garantire un’operazione fluida della rete</p>
</div>
<p>Il software più evoluto e simile ad un sistema di gestione, era quello che risiedeva nei NOC dell’operatore. Per quanto
riguarda il primo putno invece, cioè la ricerca delle rotte ammissibili e la scelta della migliore fra queste, gli
algoritmi rimanevano ancora di tipo distribuito oppure asincrono e dstribuito. Con l’avvento delle tecnologie cloud e
con l’esplosione della domanda e della varietà di requisiti richiesti, le reti con funzioni di routing classico non erano
più sufficienti. Questo ha portato a postulare una rete molto più fluida in totale controtendenza con l’ossificazione di
internet.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Con ossificazione di Internet si intende la perdita di flessibilità della rete Internet. Informalmente possiamo dire che
quella che era partita come una rete agile e resistente, è diventata una rete in cui i protocolli sono “scritti sulla pietra”.
A testimonianza di ciò, basti pensare alle difficoltà nel deployment della rete multicast WAN, oppure gli scogli che sta
incontrando il rollout di IPv6. Per un approfondimento sulla rigidità della rete Internet consultare <span id="id1">[<a class="reference internal" href="../markdown.html#id7" title="David Mazières. Ossification of the internet. 2022. doi:https://www.scs.stanford.edu/nyu/04sp/notes/l23.pdf.">Maz22</a>]</span>.</p>
</div>
<p>Per risolvere questo problema, si è accantonata la vecchia gestione della rete con i suoi algoritmi distribuiti, a favore
di una concentrazione delle capacità elaborative verso un unico dispositivo, chiamato controller. Questa migrazione delle
capacità elaborative, che informalmente possiamo definire come “migrazione dell’intelligence di rete”, ha concentrato la
funzione di elaborazione delle rotte e la scelta della migliore, dai vari dispositivi router ad un unico dispositivo
controllore. Questo ha richiesto una rivisitazione completa di come uno switch eseguiva il primo dei due punti elencati.
Per prima cosa, ha richiesto che il cotroller si prendesse carico di come raccogliere le informazioni topologiche di rete.
Seconda cosa, il controller si prende carico di ottimizzare qualunque funzionale di costo definito sul grafo ottenuto dal
passso precedente. Terza cosa, ha richiesto un metodo per la disseminazione dei risultati edl passo precedente ad ogni
singolo elemento di rete. Questo approccio, ha richiesto una completa ristrutturazione, non tanto degli algoritmi, quanto
della raccolta delle informazioni di rete e della disseminazione dei segnali inter-router. Quest’ultimo aspetto è stato
possibile ottenerlo con le nuove tecniche software applicate al networking.</p>
<p>Questo approccio molto più orientato al software, ha trovato enormi applicazioni e benefici nelle reti cloud e nel datacenter
networking. Nelle architetture datacenter abbiamo quantità massive di dispositivi da interconnettere. La sfida delle reti cloud e
del datacenter networking non nasce solo dal fatto che vi sia una quantità massiva di dispositivi, ma la sfida principale
è rappresentata dal fatto che questi dispositivi devono supportare i servizi più disparati una volta fatto il rollout.
Ragioniamo con un esempio: come posso creare una rete che un giorno sia ottimizzata per applicazioni di computing e il
giorno successivo sia ottimizzato per appliazioni che richiedono un I/O elevato. È impensabile pensare a una rete nuova
per ogni singola applicazione.  Dunque come risolviamo questo problema? Risolviamo con una rete molto più plastica ed
adattabile. Casi di successo come le reti datacenter sono una testimonianza dell’utilità di questo approccio.</p>
<div class="margin sidebar">
<p class="sidebar-title">OpenStack</p>
<p>OpenStack è una piattaforma di orchestrazione e management in tecnologia virtuale. Si affida ad una virtualizzazione di
tutte le risorse, usando un hypervisor esterno, esponendo le risorse suddivise in base al loro scopo e configurazione</p>
</div>
<p>Come riportato dalla Openstack Foundation nel
loro whitepaper  <span id="id2">[<a class="reference internal" href="../markdown.html#id6" title="OpenStack Foundation. China mobile's 5g practice based on openstack system. 2022. doi:https://events19.linuxfoundation.org/wp-content/uploads/2018/11/BayArea-Keynote-6-1200-Tianji_Jiang_OSN_China.Mobile_v7.pdf.">Fou22</a>]</span> l’operatore cinese China Mobile ha fatto il rollout della sua rete 5G con ottimi risultati.
Il caso di successo di China Mobile è uno dei tanti che testimonia la potenza delle tencologie SDN nelle reti di nuova
generazione.</p>
<p>Qui stiamo parlando di tecnologie per ambienti mobile IoT, dunque oltre alle difficoltà insite nell’ambiente IoT, abbiamo
l’inaffidabilità dovuta a oggetti mobili in ambienti potenzialmente ostili alla radiopropagazione.</p>
<ul class="simple">
<li><p>Che relazione hanno le tecniche SDN nei dataceter con il mondo IoT?</p></li>
<li><p>Quali sono gli strumenti che posso utilizzare?</p></li>
</ul>
<p>La prima domanda trova risposta nell’osservazione dei modelli matematici che sottendono entrambi i mondi. Possiamo
dimostrare che dal punto di vista del controllo, una WSN non è semplicemente una enorme rete di sensori  da controllare.
Una rete WSN, specialmente se osservata dal punto di vista dei processi di genesi e network forming, condivide molto con
il mondo del controllo del cloud datacenter networking. Un risultato sorprendente lo troviamo nell’articolo
<span id="id3">[<a class="reference internal" href="../markdown.html#id14" title="V. Bibin Christopher and J. Jasper. Jellyfish dynamic routing protocol with mobile sink for location privacy and congestion avoidance in wireless sensor networks. Journal of Systems Architecture, 112:101840, 2021. URL: https://www.sciencedirect.com/science/article/pii/S1383762120301326, doi:https://doi.org/10.1016/j.sysarc.2020.101840.">CJ21</a>]</span> in cui viene descritto l’algortimo JSDR ossia Jellyfish Sensor Dynamic Routing.
Questo algoritmo prende a prestito molto di quello era l’algoritmo originale Jellyfish per datacenter networking.<br />
Andando più nel dettaglio, questo algoritmo JSDR proviene in realtà da un altro algoritmo di routing per datacenter che
sfrutta le proprietà dei grafi casuali e le teorie sul network forming. Nell’articolo <span id="id4">[<a class="reference internal" href="../markdown.html#id15" title="Ankit Singla, Chi-Yao Hong, Lucian Popa, and P. Brighten Godfrey. Jellyfish: networking data centers randomly. In Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation, NSDI'12, 17. USA, 2012. USENIX Association.">SHPG12</a>]</span>
gli autori dimostrano come Jellyfish, un algoritmo di routing basato su un processo di network forming casuale, porti ad
grafo di Erdos-Renyi. Questo grafo di Erdos-Renyi è la rappresentazione topologica di quello che succede fra gli switch
che vengono interconnessi fra loro, grazie ad un arco, con una certa probabilità <em>p</em>. Si può dimostare come la distribuzione di
probabilità dell’esistenza di un certo arco fra lo switch <span class="math notranslate nohighlight">\(s_i\)</span> e lo switch <span class="math notranslate nohighlight">\(s_j\)</span> sia una poisson con parametro <span class="math notranslate nohighlight">\(\lambda=p\)</span>.
La cosa più sorprendente sono le prestazioni che l’algoritmo Jellyfish riesce ad ottenere. Se poniamo a confronto il throughput
medio di un’organizzazione topologica della rete secondo un fat-tree e una Jellyfish (cioè un grafo casuale), vediamo che
il grafo di switch casuale di Erdos-Renyi ha un throuput medio maggiore. Dunque con un’organizzazione totalmente casuale
della rete riesco, in media, ad ottenere prestazioni migliori. Per approfondimenti consultare <span id="id5">[<a class="reference internal" href="../markdown.html#id14" title="V. Bibin Christopher and J. Jasper. Jellyfish dynamic routing protocol with mobile sink for location privacy and congestion avoidance in wireless sensor networks. Journal of Systems Architecture, 112:101840, 2021. URL: https://www.sciencedirect.com/science/article/pii/S1383762120301326, doi:https://doi.org/10.1016/j.sysarc.2020.101840.">CJ21</a>]</span></p>
<div class="figure align-default" id="markdown-fig">
<a class="bg-primary mb-1 reference internal image-reference" href="https://reproducingnetworkresearch.files.wordpress.com/2012/06/fattree.png?w=180&amp;h=180"><img alt="fishy" class="bg-primary mb-1" src="https://reproducingnetworkresearch.files.wordpress.com/2012/06/fattree.png?w=180&amp;h=180" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Topologia Fat-Tree nel routing datacenter</span><a class="headerlink" href="#markdown-fig" title="Permalink to this image">¶</a></p>
</div>
<div class="figure align-default" id="id6">
<a class="bg-primary mb-1 reference internal image-reference" href="https://reproducingnetworkresearch.files.wordpress.com/2012/06/jellyfish.png?w=180&amp;h=180"><img alt="fishy" class="bg-primary mb-1" src="https://reproducingnetworkresearch.files.wordpress.com/2012/06/jellyfish.png?w=180&amp;h=180" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Topologia Jellyfish nel routing datacenter</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>Quella che segue è soltanto un’intuizione alla base e non una dimostrazione.
Parte del successo di Jellyfish lo possiamo intuire usando la teoria dei “piccoli mondi”. La teoria dei “piccoli mondi”
nasce da un esperimento fatto nel secolo scorso in cui una serie persone dovevano usare i loro contatti per iviare delle
lettere da una parte all’altra delgi Stati Uniti. In pratica, prendendo delle
persone a caso e chiedendo loro di spedire la lettera da una parte all’altra del mondo, tutte le lettere che sono arrivate
a destinazione, avevano in media una lunghezza di 5-6 persone intermedie. Dunque per mandare una lattera dagli US in Giappone,
si usavano soltanto 5-6 persone in media.</p>
<div class="margin sidebar">
<p class="sidebar-title">diametro di una rete</p>
<p>Il diametro di una rete è il più lungo dei cammini minimi all’interno della rete</p>
</div>
<p>Questo risultato soprendente lo rivediamo anche nel routing in datacenter. In pratica, nella topologia fat-tree ho un
diametro della rete maggiore rispetto al diametro della rete Jellyfish. Questo fatto, unito alla teoria dei piccoli mondi,
permette di postulare che il routing casuale, applicato in queste reti, non sia poi così naive come sembri. L’articolo
menzionato mostra altri risultati sorprendenti.</p>
<p>Vedendo l’algoritmo JSDR, le sue performance e la relazione che ha con il mondo del routing in datacenter, la domanda ora
diventa:</p>
<ul class="simple">
<li><p>similmente al caso Jellyfish, possiamo estendere gli algoritmi odierni sfruttando i processi di network forming?</p></li>
<li><p>Se sì, otteniamo gli stessi vantaggi anche nel mondo IoT?</p></li>
</ul>
<p>Partiamo dalla seconda domanda. Dando per buono, per ora, che possiamo usare i processi di network forming per ottenere
algoritmi più performanti, come posso essere sicuro che effettivamente ho un vantaggio? Dobbiamo definire cosa per noi è
un vantaggio. Un vantaggio in termini di perfomance in una rete deve essere misurato tramite l’uso di una qualche metrica.
Le metriche più comuni che oggi vengono usate sono:</p>
<ul class="simple">
<li><p>throughput</p></li>
<li><p>latenza</p></li>
<li><p>probabilità di perdita di pacchetto</p></li>
<li><p>probabilià di disconnessione</p></li>
<li><p>robustezza della rete</p></li>
</ul>
<p>Un aspetto che sarà fondamentale nella trattazione seguente è:
che tipo di routing si può usare?</p>
<p>Questa domanda è fondamentale in quanto, se usiamo il routing classico, allora otterrò le odierne WSN. Mentre invece se
migrassi verso un approccio molto software-oriented, ottengo una SDN per sensori. Quest’ultima cosa comporta l’
installazione di un controller.</p>
<p>Adesso la domanda fondamentale:
Che vantaggio mi porta l’aggiunta di un elemento “estraneo” al mondo IoT come il controller?</p>
<p>Rispondiamo a questa domanda, ed alla prima, con una serie di casi d’uso in cui è possibile ottenere ottime prestazioni
e aprire scenari impossibili da coprire con le reti attuali. Si propone una trattazione di algoritmi per i seguenti casi:</p>
<ul class="simple">
<li><p>Allocazione ottima delle risorse</p></li>
<li><p>Controllo della congestione</p></li>
<li><p>Aumento della robustezza della rete</p></li>
</ul>
<p>Ognuno di questi casi verrà esaminato nel corrispondente paragrafo nel capitolo finale. Ciascuna delle sezioni sull’
analisi dei risultati illustrerà le risposte alle domande tramite emulazione nell’ambiente GNS3.</p>
<div class="section" id="netapp-e-controller">
<h2>NetApp e controller<a class="headerlink" href="#netapp-e-controller" title="Permalink to this headline">¶</a></h2>
<p>Con la parola NetApp ci riferiamo ai moduli che implementano gli algoritmi proposti all’interno del controller.
L’architettura di rete è costituita da più piani logici o fisici di interconnessione fra i dispositivi, come in figura:</p>
<div class="figure align-default" id="id8">
<a class="bg-primary mb-1 reference internal image-reference" href="https://d3i71xaburhd42.cloudfront.net/5c61431e479245b1235b30de20aa89ebc188189c/6-Figure2-1.png"><img alt="fishy" class="bg-primary mb-1" src="https://d3i71xaburhd42.cloudfront.net/5c61431e479245b1235b30de20aa89ebc188189c/6-Figure2-1.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Rappresentazione dei vari piani di connessione, cortesia di <span id="id7">[<a class="reference internal" href="../markdown.html#id8" title="Jose A. Ordonez-Lucena, Pablo Ameigeiras, Diego R. López, Juan J. Ramos-Muñoz, Javier Lorca, and Jesús Folgueira. Network slicing for 5g with sdn/nfv: concepts, architectures, and challenges. IEEE Communications Magazine, 55:80-87, 2017.">OLALopez+17</a>]</span></span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>Per ottenere un’architettura come quella in figura, è necessario utilizzare un controller centrale che possa creare i
collegamenti logici attraverso un routing intelligente fra i vari dispositivi.</p>
<p>Andando più nel dettaglio con l’architettura del sistema controller, possiamo che sono due i design pattern fondanti:</p>
<ol class="simple">
<li><p>Publish-subscribe</p></li>
<li><p>Decorator</p></li>
</ol>
<p>Iniziamo descrivendo il secondo design pattern. Il pattern decorator è un pattern che permettere di aggiornare le funzionalità
a runtime della mia classe. In python la questione è diversa. L’esecuzione del codice avviene in due fasi diverse:</p>
<ul class="simple">
<li><p>Import time</p></li>
<li><p>Execution time
Nell’import time abbiamo che l’interprete esegue tutte le istruzioni di importazione di librerie esterne e dichiara classi,
metodi, funzioni e variabili globali. Questo viene fatto <strong>prima</strong> che venga eseguita qualunque istruzione di codice.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">registry</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;registering (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="p">)</span>
    <span class="n">registry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List before decoration &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">registry</span><span class="p">))</span>

<span class="nd">@register</span>    <span class="c1"># Questa funzione viene eseguita prima dl contenuto della funzione decorata</span>
<span class="k">def</span> <span class="nf">f1</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running f1()&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;List after decoration&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">registry</span><span class="p">))</span>

<span class="n">f1</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>List before decoration []
registering (&lt;function f1 at 0x000001C5510E1280&gt;)
List after decoration[&lt;function f1 at 0x000001C5510E1280&gt;]
Running f1()
</pre></div>
</div>
</div>
</div>
<p>Questo design pattern viene sfruttato per esrguire una registrazione dei metodi e delle classi nel controller. In queste
classi ho codificato il comportamento che deve avere il controller. Giusto qualche esempio:
Il seguente listato mostra un pezzo della dichiarazione di una classe OFP (OpenFlow) Hello message packet. In questa classe
si trova il comportamento che il controller deve adottare. Nella convenzione Ryu il risultato è una classe, il cui pezzo
inziziale, è come sotto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@_register_parser       # primo decorator che registra questa classe come parser di un pacchetto OpenFlow
@_set_msg_type(ofproto.OFPT_HELLO)   # Secondo decorator &quot;stacked&quot; che dice che tipo di evento crea (OFPT_HELLO)
class OFPHello(MsgBase):
    &quot;&quot;&quot;
    Hello message
    When connection is started, the hello message is exchanged between a
    switch and a controller.
</pre></div>
</div>
<p>Per ogni tipo di messaggio OpenFlow devo seuire la procedura accennata sopra e cioè:</p>
<ul class="simple">
<li><p>Dichiarare che tipo di messaggio sto parlando</p></li>
<li><p>Decorare la classe se sto descrivendo un parser, cioè una classe che descrive come comportarsi con quel pacchetto</p></li>
<li><p>Decorare la classe dicendo che tipo di evento scateno alla ricezione del pacchetto in oggetto</p></li>
<li><p>Dichiarare metodi e variabili locali relativi al parsing di quel pacchetto</p></li>
</ul>
<p>Per quale motivo dichiarare quale evento viene scatenato alla ricezione e parsing di quel pacchetto?</p>
<p>Poiché ragiono con un design pattern principale che è publish-subscribe, un design pattern di tipo reattivo che reagisce
a degli eventi esterni. Dunque ciò che faccio è usare gli eventi come input al mio sistema. A questo punto ci chiediamo:</p>
<p>Il mio controller riceve pacchetti o riceve eventi?</p>
<p>Il controller riceve pacchetti, nessuno switch può emettere eventi… Può solo generare pacchetti secondo la specifica
di OpenFlow desiderata. Allora cosa c’entrano gli eventi? Osserviamo la seguente figura:</p>
<div class="figure align-default" id="id9">
<a class="bg-primary mb-1 reference internal image-reference" href="../_images/Cattura.JPG"><img alt="fishy" class="bg-primary mb-1" src="../_images/Cattura.JPG" style="width: 800px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Architettura del controller (immagine temporanea)</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>Quello che è il loop centrale è la socket in ascolto. Il sottosistema a valle della socket in ascolto è tutta la parte
di controller che si occupa di:</p>
<ul class="simple">
<li><p>fare il parsing del pacchetto</p></li>
<li><p>riconoscere il pacchetto ed estrarre le info rilevanti</p></li>
<li><p>popolare una classe (o struct dati) che sarà la struttura dati che contiene le informazioni dell’evento</p></li>
<li><p>Sfruttare i meccanismi di publish interni</p></li>
<li><p>propagare l’evento ai event handler che hanno fatto subscribing a quel preciso evento</p></li>
</ul>
<p>Quello che chiamo UoW cioè Unit of Work (nome preso da <span id="id10">[<a class="reference internal" href="../markdown.html#id9" title="H. Percival and B. Gregory. Architecture Patterns with Python: Enabling Test-Driven Development, Domain-Driven Design, and Event-Driven Microservices. O'Reilly Media, 2020. ISBN 9781492052173. URL: https://books.google.it/books?id=P5DUDwAAQBAJ.">PG20</a>]</span>) è un tipo di comportamento.
Ad esempio, come mi comporto quando ricevo un HELLO? Come mi comporto quando ricevo un PACKET_IN? E via dicendo con tutti
i pacchetti definiti dalla specifica OpenFlow. Tutti questi comportamenti che devo tenere ogni volta che ricevo un certo
pacchetto (anche solo per generare l’evento e notificare gli altri) lo codifico in questi UoW. Poiché questi UoW durante
le varie release variano leggermente, non è bene dichiarare una nuova classe per ogni release. Ciò che faccio è usare una
sorta di repository dei tipi di pacchetti e chiedere ad ogni classe di istanziare il comportamento corretto in base a:</p>
<ul class="simple">
<li><p>Versione di OpenFlow</p></li>
<li><p>Tipo di pacchetto</p></li>
</ul>
<p>Oltre a codificare i comportamenti che il controller deve intraprendere quando riceve un pacchetto, con questi UoW ci
specifico anche che tipo di processing fare con le info che il controller ha a disposizione. Per esempio se voglio
specificare come un certo Switch debba processare un certo pacchetto io posso toccare la sua pipeline di processing del
pacchetto usando dei pacchetti OpenFlow (ad esempo FlowMod) prodotti secondo le istruzioni di questo UoW. Segue un listato
di esempio:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if ofproto.OFP_VERSION == ofproto_v1_0.OFP_VERSION:
                rule = nx_match.ClsRule()
                rule.set_dl_dst(addrconv.mac.text_to_bin(lldp.LLDP_MAC_NEAREST_BRIDGE))
                rule.set_dl_type(ETH_TYPE_LLDP)
                actions = [ofproto_parser.OFPActionOutput(ofproto.OFPP_CONTROLLER, self.LLDP_PACKET_LEN)]
                dp.send_flow_mod(
                    rule=rule, cookie=0, command=ofproto.OFPFC_ADD,
                    idle_timeout=0, hard_timeout=0, actions=actions,
                    priority=0xFFFF)
</pre></div>
</div>
<p>In questo modulo del controller Ryu (il UoW) vediamo come dopo un controllo della versione creo un oggetto che mi servirà
per il matching dei vari campi del pacchetto LLDP. La variabile <code class="docutils literal notranslate"><span class="pre">actions</span></code> contiene il codice della specifica OpenFlow che
corrisponde al comportamento che voglio che lo switch abbia. In questo caso io controller voglio che lo switch abbia una
flow rule relativa ai pacchetti LLDP. Questa flow rule, che codifica il comportamento desiderato, riusciamo ad intuirla
vedendo la variabile “action”. Dal listato si vede che lo switch dovrà inviare indietro al controller (tramite packet in)
il pacchetto LLDP che ha fatto matching. Questo descritto ora è il comportamento previsto dalle specifiche OpenFlow per
quanto riguarda la topology discovery. Questo descritto è soltanto un esempio di quali comportamenti posso codificare nel
switch. Ve ne sono molti altri, invito a guardare la repository del progetto per vedere come si codifica ogni singolo
comportamento, logica e funzione di rete.</p>
<p>Questi moduli sono coloro che fattivamente una volta prese le info di rete, calcoleranno lo stato desiderato e
dissemineranno le istruzioni ai vari switch per arrivare a quello stato desiderato. Vista così l’implementazione più
naturale dei vari algoritmi è quella iterativa. Non uso ricorsione, tutti gli algoritmi sono di tipo iterativo in quanto
dimostro che esista una sequenza di passi finita che porterà il mio sistema dallo stato attuale (il punto A) ad un punto
B (lo stato desiderato) attraverso piccoli passi nello spazio dei comportamenti ammissibili.</p>
<p>Nell’ultimo capitolo espongo i risultati delle simulazioni ottenuti con questi UoW, invito a consultare la repository del
progetto per il codice sorgente alla base di queste simuzlazioni.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="sensor.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Reti di sensori</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="optimization.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Ottimizzazione del traffico</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Andi Dulla<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>