
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Analisi dei dati ottenuti dalla applicazione di controllo distribuito &#8212; Tesi Andi Dulla</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Albero ricoprente di costo minimo capacitato" href="main_pipeline.html" />
    <link rel="prev" title="Distribuzioni stabili" href="stable.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Tesi Andi Dulla</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   SDN forming per mobile IoT
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Strumenti
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="sensor.html">
   Reti di sensori
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Teoria
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="optimization.html">
   Ottimizzazione del traffico
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stable.html">
   Distribuzioni stabili
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Risultati simulazione
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Analisi dei dati ottenuti dalla applicazione di controllo distribuito
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="main_pipeline.html">
   Albero ricoprente di costo minimo capacitato
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="frank-wolfe.html">
   Metodo Frank &amp; Wolfe
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../_sources/chapters/analisi_dati_rete_BOBI.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/chapters/analisi_dati_rete_BOBI.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/executablebooks/jupyter-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fchapters/analisi_dati_rete_BOBI.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/chapters/analisi_dati_rete_BOBI.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ipotesi-e-statement-del-problema">
   Ipotesi e statement del problema
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#statement-del-problema">
   Statement del problema
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#esempio-di-non-stazionierita-del-segnale-traffico-medio">
     Esempio di non stazionierità del segnale traffico medio
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#osservazione-dei-dati">
     Osservazione dei dati
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conlusioni-analisi-empirica-dei-dati">
     Conlusioni analisi empirica dei dati
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modello-della-rete">
   Modello della rete
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#efficienza-ed-equita">
   Efficienza ed equità
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#allocazione-ottima-delle-risorse">
   Allocazione ottima delle risorse
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ipotesi-1">
     Ipotesi 1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#proportional-fairness">
     Proportional fairness
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#esempio">
       Esempio
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algoritmi-per-il-controllo-della-congestione">
   Algoritmi per il controllo della congestione
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algoritmi-centralizzati-metodi-sdn">
   Algoritmi centralizzati: metodi SDN
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Analisi dei dati ottenuti dalla applicazione di controllo distribuito</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ipotesi-e-statement-del-problema">
   Ipotesi e statement del problema
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#statement-del-problema">
   Statement del problema
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#esempio-di-non-stazionierita-del-segnale-traffico-medio">
     Esempio di non stazionierità del segnale traffico medio
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#osservazione-dei-dati">
     Osservazione dei dati
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#conlusioni-analisi-empirica-dei-dati">
     Conlusioni analisi empirica dei dati
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modello-della-rete">
   Modello della rete
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#efficienza-ed-equita">
   Efficienza ed equità
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#allocazione-ottima-delle-risorse">
   Allocazione ottima delle risorse
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ipotesi-1">
     Ipotesi 1
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#proportional-fairness">
     Proportional fairness
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#esempio">
       Esempio
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algoritmi-per-il-controllo-della-congestione">
   Algoritmi per il controllo della congestione
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algoritmi-centralizzati-metodi-sdn">
   Algoritmi centralizzati: metodi SDN
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="analisi-dei-dati-ottenuti-dalla-applicazione-di-controllo-distribuito">
<h1>Analisi dei dati ottenuti dalla applicazione di controllo distribuito<a class="headerlink" href="#analisi-dei-dati-ottenuti-dalla-applicazione-di-controllo-distribuito" title="Permalink to this headline">¶</a></h1>
<p>Innanzitutto bisogna chiedersi perché è necessario parlare di controllo della rete e delle topologie. È necessario parlare
di controllo ottimo della rete perché è la procedura che mi permette di garantire un’operazione corretta ed affidabile
della rete. I problemi di stabilità della rete e la necessità di controllo nella rete, nasce dalla natura del mezzo fisico
con cui interconnetto i vari device e dalla gestione dell’accesso al mezzo fisico. Il controllo della rete può essere
fatto in più modi attraverso:</p>
<ul class="simple">
<li><p>gestione dei metodi di accesso del canale</p></li>
<li><p>gestione dei traffici che generano un’evoluzione dello stato del sistema</p></li>
</ul>
<p>La gestione del controllo della rete attraverso i metodi di accesso al canale è una macro categoria di cui non mi occupo.
Per quanto riguarda il controllo della rete mi occupo del problema a livello E2E nell’ottima di controllo della
congestione e controllo di flusso (primariamente attraverso TCP).</p>
<p>Espongo l’analisi dei dati e le conclusioni che ho tratto fino ad ora con le simulazioni.</p>
<div class="section" id="ipotesi-e-statement-del-problema">
<h2>Ipotesi e statement del problema<a class="headerlink" href="#ipotesi-e-statement-del-problema" title="Permalink to this headline">¶</a></h2>
<p>Ipotizzo che la trasmissione dei dati soprattutto nel piano di controllo della mia rete segua una distribuzione heavy-
tailed e che al limite converga ad una distribuzione stabile.</p>
<p>L’ipotesi è duplice:</p>
<ul class="simple">
<li><p>Il mio sistema genera dati nel piano di controllo con una distribuzione heavy-tailed</p></li>
<li><p>Il processo che genera dati se osservato per un tempo sufficientemente lungo converge ad una distribuzione stabile</p></li>
</ul>
<p>Il problema del primo punto è che fare un fit per una distribuzione heavy-tailed è estremamente complicato e i dettagli
matematici sono particolarmente tecnici. Da un punto di vista numerico i test <span class="math notranslate nohighlight">\( \chi^2 \)</span> impone di conoscere la
distribuzione sottostante così che possa verificare le “discrepanze” osservate siano sotto un certo valore. Questa
distribuzione sottostante di probabilità non ce l’ho, non posso andare “a tentoni” provando tutte le varie distribuzioni
fino a che no trovo quella con uno score minimo. Non posso neanche fare un fit con la log-verosimiglianza cercando con un
MLE di trovare i vari parametri che compongono le distribuzioni, poiché i dati finiscono in regioni inammissibili dei
metodi di ottimizzazione e quindi i valori calcolati sono spesso inaffidabili o con bound di incertezza così elevati che
rendono inutili le stime prodotte.</p>
<p>Dunque per dimostrare il primo punto posso solo osservare che i dati di lunghezza dei pacchetti sulle reti dati (eg Internet)
sono sempre stati classificati come distribuiti secondo pdf heavy-tailed. Il metodo usato solitamente è quello di fare
una mean-excess analysis e vedere com’è fatta la distribuzione dei valori eccezionali. Un secondo metodo empirico che uso
io in virtù del fatto che il processo sottostante è calssificabile come heavy-tailed, vado a cercare conferma della mia
ipotesi guardando la media mobile a corto termine e poi allungando la lunghezza del filtro moving average. Se ottengo un
con tempovariante e con un running average che mostra un trend questo è una condizione necessaria all’essere heavy tailed.</p>
</div>
<div class="section" id="statement-del-problema">
<h2>Statement del problema<a class="headerlink" href="#statement-del-problema" title="Permalink to this headline">¶</a></h2>
<p>Ipotizzo che una rete di sensori in ambito mobile IoT abbia bisogno di una applicazione di rete per il controllo ottimo:</p>
<ul class="simple">
<li><p>del traffico</p></li>
<li><p>della topologia</p></li>
<li><p>delle congestioni</p></li>
<li><p>degli sprechi in termini di banda/energia/slot-temporali</p></li>
</ul>
<p>Il problema principale deriva dal fatto che il mezzo trasmissivo che sto usando è wireless ed usando un modello a livello
fisico scopro che ci sono interferenze in ambienti in cui uso radio-propagazione. Solitamente questi problemi vengono
chiamati come il problema del terminale nascosto e terminale scoperto. La soluzione proposta per questi due problemi
“classici” è quella di usare un controllo centralizzato oppure l’uso di pacchetti RTS/CTS. Ognuno di questi metodi ha i
suoi pregi e difetti. Mi concentro sul metodo del controllo centralizzato poiché è quello meno investigato di tutti in
ambiente sensori mobile IoT.</p>
<div class="section" id="esempio-di-non-stazionierita-del-segnale-traffico-medio">
<h3>Esempio di non stazionierità del segnale traffico medio<a class="headerlink" href="#esempio-di-non-stazionierita-del-segnale-traffico-medio" title="Permalink to this headline">¶</a></h3>
<p>Nel seguente dataset raccolto da un insieme di dispositivi con un’applicazione di controllo simile a quella usata nelle
simulazioni del network forming. Dai risultati esposti con questo dataset ed il dataset delle simulazioni della tesi
vediamo la conferma di ciò che viene riportato in <span id="id1">[<a class="reference internal" href="../markdown.html#id7" title="Félix Hernández-Campos, J. S. Marron, F. Donelson Smith, and Gennady Samorodnitsky. Variable heavy tailed durations in internet traffic, part i: understanding heavy tails. In 10th International Workshop on Modeling, Analysis, and Simulation of Computer and Telecommunication Systems (MASCOTS 2002), 11-16 October 2002, Fort Worth, Texas, USA, 43. IEEE Computer Society, 2002. URL: http://csdl.computer.org/comp/proceedings/mascots/2002/1840/00/18400043abs.htm.">HCMSS02</a>]</span>.
Nell’articolo viene dimostrato come traffici di tipo HTTP o simili siano distribuiti secondo pmf con heavy-tails. Nell’
articolo menzionato viene data una modellazione dettagliata di quello che è la distribuzione del traffico. <strong>Non</strong> ripeto
l’analisi fatta da loro, semplicemente è un’osservazione della ecdf e tramite osservazione affermano che il traffico segue
le loro previsioni. Nella sezione dell’articolo citato viene data una dimostrazione delle proprietà delle pmf heavy-tailed
e con una stima cercano di ottenere l’indice di coda che caratterizza il traffico.
La mia analisi è molto più semplice in questo documento, mi limito a osservare che per il teorma limite centrale della
probabilità io so che:
<span class="math notranslate nohighlight">\(\displaystyle P[X_1+X_2+X_3...] \sim N(\mu, \sigma) \)</span> dove <span class="math notranslate nohighlight">\( \mu = \frac{1}{N}(\sum_{i=1}^N X_i) \)</span> ciò che questo dice
è che la somma di N variabili aleatorie convergerà ad una gaussiana con <span class="math notranslate nohighlight">\(\mu\)</span> la media campionaria. Questo è vero in una
moltitudine di casi, tra l’altro, la media campionaria è un’ottmo stimatore dela valore medio di una moltitudine di altre
distribuzioni di probabilità. Perché concentrarsi tanto sulle distribuzioni heavy-tailed? Perché il teorma limite della
probabilità <strong>non</strong> vale nel caso delle distribuzioni fat-tailed. Per convincersene basta osservare che per le funzioni
regolarmente non variabili la “probabilità estrema” e cioè la probabilità che si avverino eventi “estremi” è molto più
probabile che l’evento normale. Questo si può vedere osservando che una distribuzione fat-tailed se ne definiamo la
<em>survival function</em> <span class="math notranslate nohighlight">\( F \)</span> din una v.a. <span class="math notranslate nohighlight">\( X \)</span> tale che <span class="math notranslate nohighlight">\( \overline{F}(X) = 1-F(X)=Prob[X&gt;x] \)</span> allora indico con la seguente
scrittura <span class="math notranslate nohighlight">\( \overline{F}(X) \sim x^{-\alpha}, x \to \infty \)</span> per indicare che
<span class="math notranslate nohighlight">\(\lim_{x\to \infty} \frac{\overline{F}(X)}{x^{-\alpha}} \to 1 \)</span>. Qui <span class="math notranslate nohighlight">\(\alpha\)</span> è il tail index cioè la velocità con cui la
probabilità tende a un valore maggiore di <span class="math notranslate nohighlight">\( x \)</span> con <span class="math notranslate nohighlight">\( x\to \infty \)</span>. Nelle distribuzioni per cui vale il teorma limite
centrale questo tasso <span class="math notranslate nohighlight">\( \alpha \)</span> è polinomiale, nelle distribuzioni fat-tailed è <em>subesponenziale</em>. Questo cosa comporta?
Comporta il fatto che: <br>
<span class="math notranslate nohighlight">\(\displaystyle P[X_1+X_2+X_3...] \sim P[max(X_1, X_2, X_3, 0...) &gt; x], x \to \infty \)</span> <br>
Tutto ciò che viene descritto qui è soltanto un <em>limiting behavior</em> cioè caratteristiche che si manifestano solo al limite.
Il risultato di tutto è il seguente:</p>
<ul class="simple">
<li><p>Le medie storiche sono <em>inaffidabili</em> per la predizione</p></li>
<li><p>Le differenze fra due predizioni successivamente sempre più “lontane” non decresce</p></li>
<li><p>Il rapporto di due valori record successivi fra di loro non descesce</p></li>
<li><p>La media di eventi in eccesso rispetto a una soglia aumenta all’aumentare della soglia</p></li>
<li><p>L’incertezza dello stimatore statistico del comportamento medio di <span class="math notranslate nohighlight">\(n\)</span> variabili aleatorie è simile a quelle originali</p></li>
<li><p>I coefficienti delle regressioni che proviamo in molti casi danno risultati errati</p></li>
</ul>
<p>Un errore molto comune e molto grave che viene commesso è quello di basare previsioni di dati di risk return nelle operazioni
di trading finanziario usano la teoria “classica” invece che le distribuzioni fat-tailed e le loro cautele necessarie (si
veda il libro del dott. Taleb al riguardo)</p>
<p>Ritornando ai dati, ciò che possiamo dire è che in un campione finito della popolazione, necessariamente i miei stimatori
convergeranno a qualcosa di finito e le loro deviazioni standard, per quanto elevate, saranno finite. Ciò non dovrebbe
trarre in inganno, poiché i miei stimatori mi possono dire che convergo a qualcosa quando in realtà sto inseguendo una
quantità che diverge… Pensiamo ad esempio a stimare la media di una distribuzione di Cauchy. La distibuzione di Cauchy
è una delle distribuzioni più “classiche” fra quelle fat-tailed in quanto ha una forma chiusa abbastanza usabile per le
stime a massima verosimiglianza. La media della distribuzione di Cauchy <em>non</em> è definità poiché l’integrale non converge,
lo stimatore MLE sì converge… A cosa converge? Ad un valore nullo, ma se non conosco la distribuzione sottostante io non
saprei che convergo a un valore spazzatura, per questo motivo bisogna fare molta attenzione alle distibuzioni fat-tailed
in quanto convergono a delle distribuzioni <em>stabili</em> piuttosto che a una gaussiana.</p>
</div>
<div class="section" id="osservazione-dei-dati">
<h3>Osservazione dei dati<a class="headerlink" href="#osservazione-dei-dati" title="Permalink to this headline">¶</a></h3>
<p>Il seguente dataset come anticipato mostra i “sintomi” di distribuzioni fat-tailed, <strong>non</strong> faccio un’analisi approfondita
in questo documento ma mi limiterò a enunciare i risultati in modo qualitativo. In particolare:</p>
<ul>
<li><p>Nel caso che la media mobile mostri chiaramente segnali di trend è plausibile ipotizzare una distribuzione fat-tailed</p>
<p>Utilizzo un data set spesso usato per dimostrare queste proprietà, non l’ho raccolto io</p>
</li>
</ul>
<p>In realtà non è che nei miei dati ci sia un trend è solo che sto usando lo stimatore sbagliato. Nel dataset riportato
si osserva proprio questo. Il dataset seguente è un dataset di parametri economici preso dal progetto GECON:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../../data/GECON dataset.csv&quot;</span><span class="p">)</span>
<span class="n">copyds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">moving_average</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">w</span>


<span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;16&quot;</span><span class="p">,</span> <span class="s2">&quot;32&quot;</span><span class="p">]</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Dataset che a priori so essere fat-tailed&quot;</span><span class="p">,</span>
             <span class="n">fontproperties</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="k">for</span> <span class="n">win_length</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
    <span class="n">vsct</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">copyds</span><span class="p">[</span><span class="s2">&quot;Bps&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span><span class="p">))</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running average con </span><span class="si">{</span><span class="n">win_length</span><span class="si">}</span><span class="s2"> punti&quot;</span><span class="p">,</span>
                      <span class="n">fontproperties</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">vsct</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vsct</span><span class="p">)))})</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Sample number&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Economic params [€]&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/analisi_dati_rete_BOBI_1_0.png" src="../_images/analisi_dati_rete_BOBI_1_0.png" />
</div>
</div>
<p>Dai plot sopra, nonostante abbia fatto una media mobile con una lunghezza della finestra notevole ripsetto al numero di
campioni, questo non è risultato sufficiente a togliere i “trend” nei dati. Questa caratteristica che abbiamo osservato
qualitativamente è un segnale di comportamento self-similar caratteristico nelle reti dati. Ripropongo la stessa
visualizzazione con i dati della rete:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../../data/1 ora eserczio rete con piano lavoro REST.csv&quot;</span><span class="p">)</span>
<span class="n">net_ds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
<span class="c1"># indexNames = net_ds[net_ds[&#39;Bps&#39;] &lt; 1000].index</span>
<span class="c1"># net_ds.drop(indexNames, inplace=True)</span>
<span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;128&quot;</span><span class="p">,</span> <span class="s2">&quot;256&quot;</span><span class="p">,</span> <span class="s2">&quot;512&quot;</span><span class="p">,</span> <span class="s2">&quot;1024&quot;</span><span class="p">]</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Dataset raccolto dalle simulazioni&quot;</span><span class="p">,</span>
             <span class="n">fontproperties</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="k">for</span> <span class="n">win_length</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
    <span class="n">vsct</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">net_ds</span><span class="p">[</span><span class="s2">&quot;Bps&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span><span class="p">))</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running average con </span><span class="si">{</span><span class="n">win_length</span><span class="si">}</span><span class="s2"> punti&quot;</span><span class="p">,</span>
                      <span class="n">fontproperties</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">vsct</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vsct</span><span class="p">)))})</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Data rate [Bps]&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/analisi_dati_rete_BOBI_3_0.png" src="../_images/analisi_dati_rete_BOBI_3_0.png" />
</div>
</div>
<p>Il fatto che questi dati suggeriscano una presenza di distribuzioni di tipo fat-tailed induce a riflettere nel trarre le
conclusioni. Una rete dati mostra un comportamento fat-tailed, dunque al limite tenderà ad una distribuzione <em>stable</em>.
Questo che conseguenze ha nella pratica? Ragioniamo facendo uso di un ulteriore strumento: la teoria dei valori estremi.
Secondo questa congettura nelle distribuzioni fat-tailed si vede un’applicazione del detto:”al peggio non c’è mai fine”.
Questo lo possiamo dire ragionando sui dati degli uragani negli USA i quali sono distribuiti in modo fat-tailed. Per quanto
riguarda i dati distribuiti in modo fat-tailed e le loro proprietà applicati al dataset degli uragani, possiamo dire che
usando la distribuzione degli eventi eventi in eccesso definita come <span class="math notranslate nohighlight">\( P[X&gt;x|X&gt;u] \)</span> possiamo dire che in tutti i dataset
si osserva che <span class="math notranslate nohighlight">\(\displaystyle E(P[X&gt;x|X&gt;u]) \)</span> per la linearità dell’operatore media possiamo dire che se fissata una soglia
<span class="math notranslate nohighlight">\( u \)</span> e volendo, fra tutti i valori oltre la soglia, cercare gli eventi estremi, possiamo dire che la loro media sarà
sempre e comunque maggiore della soglia. Tutto ciò applicato agli uragani ci permette di dire che fissata una soglia di
danni economici causati da questi uragani, presa una certa soglia, la media dei danni sarà maggiore di quella soglia. Da
questo possiamo dire che guardando agli uragani non è possibile trovare ujna soglia <span class="math notranslate nohighlight">\( u \)</span> tale che <span class="math notranslate nohighlight">\(E(P[X&gt;x|X&gt;u]) &lt; u \)</span>
e questo è vero anche se spingo sempre più la soglia dei danni, al peggio non c’è mai fine…</p>
<p>Questo principio vale per tutti i dati distribuiti secondo pmf fat-tailed, dunque anche per i dati che ho raccolto nella
rete con controllo 1-hop. Anche le altre reti di sensori wifi generali si comportano in questo modo, dimostro la precedente
con un precedente dataset raccolto in una rete wifi non infrastrutturata con un’applicazione di generazione dati UDP.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../../data/capture_wifi.csv&quot;</span><span class="p">)</span>
<span class="n">net_ds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
<span class="c1"># indexNames = net_ds[net_ds[&#39;Bps&#39;] &lt; 1000].index</span>
<span class="c1"># net_ds.drop(indexNames, inplace=True)</span>
<span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;32&quot;</span><span class="p">,</span> <span class="s2">&quot;64&quot;</span><span class="p">,</span> <span class="s2">&quot;128&quot;</span><span class="p">,</span> <span class="s2">&quot;256&quot;</span><span class="p">]</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Dataset wifi ad-hoc network&quot;</span><span class="p">,</span>
             <span class="n">fontproperties</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
<span class="k">for</span> <span class="n">win_length</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
    <span class="n">vsct</span> <span class="o">=</span> <span class="n">moving_average</span><span class="p">(</span><span class="n">net_ds</span><span class="p">[</span><span class="s2">&quot;Bps&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">win_length</span><span class="p">))</span>
    <span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running average con </span><span class="si">{</span><span class="n">win_length</span><span class="si">}</span><span class="s2"> punti&quot;</span><span class="p">,</span>
                      <span class="n">fontproperties</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">vsct</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vsct</span><span class="p">)))})</span>
    <span class="n">sns</span><span class="o">.</span><span class="n">regplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">scatter</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">p</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Time [s]&quot;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Data rate [Bps]&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/analisi_dati_rete_BOBI_5_0.png" src="../_images/analisi_dati_rete_BOBI_5_0.png" />
</div>
</div>
</div>
<div class="section" id="conlusioni-analisi-empirica-dei-dati">
<h3>Conlusioni analisi empirica dei dati<a class="headerlink" href="#conlusioni-analisi-empirica-dei-dati" title="Permalink to this headline">¶</a></h3>
<p>La cosa principale che capiamo da questi grafici e le formule esposte è il fatto che: il fatto che al peggio non ci sia
mai fine vale anche nella rete. Questo lo capiamo in quanto i dataset appartengono a categorie di applicazioni generiche
che sono distribuite, tutte quante, secondo distribuzioni fat-tailed. Dunque, anche per le reti vale la proprietà
riguardante la excess distribution per la quale fissata una soglia di throughput lungo il control plane, la media dei
throughput osservati nella excess distribution cioè tali per cui <span class="math notranslate nohighlight">\( X&gt;u \)</span> la media di questi throughput osservati sarà
sempre maggiore della soglia. Peggio ancora, più spingo la soglia dei throughput e anche lì la media dei dati osservati
sarà in ogni caso maggiore della soglia, in teoria anche se la soglia viene trascinata al limite… Quest’ultima cosa
avviene ad esempio nei casi di broadcast storm.</p>
<p>Come dimostrazione finale mostro un fit fatto con la survivor function della distribuzione fat-tailed dei miei dati ed
una distribuzione fat-tailed del tipo Pareto generalizzata <img height="400" src="C:\Users\DULLA\PycharmProjects\Thesis_Data_Analisys\assets\fit.jpg" width="400"/></p>
</div>
</div>
<div class="section" id="modello-della-rete">
<h2>Modello della rete<a class="headerlink" href="#modello-della-rete" title="Permalink to this headline">¶</a></h2>
<p>Adesso analizziamo una applicazione di controllo della rete, questo per mitigare le problematiche esposte prima attraverso
la distribuzione dei dati.</p>
<p>Una prima soluzione è quella di identificare gli eventi estremi e risolvere quei casi. Ragionanando in questo modo possiamo
pensare che l’evento catastrofico da risolvere siano i broadcast storm dovuti ai cicli nella rete.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>soluzione: eliminiamo i cicli ed usiamo STP
</pre></div>
</div>
<p>Questa soluzione non tiene conto della stabilità della rete… È possibile dimostrare che una rete con UDP è modellabile
dal punto di vista della propagazione dati come un sistema lineare e quindi posso fare un’analisi della stabilità.
Ciò che si può dimostrare è che una rete con UDP è un sistema stabile ma che in generale ha caratteristiche di margine di
fase molto fragili, basta poco per far “scoppiare” la rete. Per convicnersene basti pensare cagli attacchi “smurf” cioè
di amplificazione, principalmente utilizzano protocolli trasporto che non prevedono controlli distribuiti sul carico immesso
nella rete (ad esempio broadcast ping). Col protocollo TCP risolviamo il problema, grazie al protocollo e ai suoi algoritmi
di gestione della congestione (livello IP) e del flusso (sliding window), non sono soluzioni definitive in quanto non
effettuo un’ottimizzazione congiunta ma opero su due livelli diversi, ma è comunque un buon risultato.</p>
<p>Quest’ultima frase significa che nel piano di controllo di una rete di sensori SDN è necessario usare protocolli di
trasmissione con qualche meccanismo di controllo della congestione e di controllo del flusso, anche basilari. Se queste
precazioni non vengono intraprese, ci esponiamo al rischio di overflowing dei dispositivi. Questo perché nel piano di controllo
ipotizzato nella simulazione, ho 1 hop di propagazione. Con unm modello del genere, nel caso peggiore trasmetterò un
numero <span class="math notranslate nohighlight">\( o(n^2) \)</span> pacchetti con <span class="math notranslate nohighlight">\(n\)</span> numero di nodi. Il bound quadratico nel numero dei nodi si giustifica pensando che
qualunque pacchetto da qualunque nodo verrà ritrasmesso in ogni collegamento. Il caso peggiore è che ci sia un messaggio
per ogni collegamento e per ogni nodo, cioè <span class="math notranslate nohighlight">\( \frac{n(n-1)}{2} \sim n^2 \)</span> in pratica la situazione di una mesh.</p>
<p>Nello studio dell’applicazione di controllo della rete, intanto inizio studiando gli algoritmi di controllo distribuiti.
Principalmente gli algoritmi di controllo del carico su una rete sono di due tipi:</p>
<ul class="simple">
<li><p>Distribuito</p></li>
<li><p>Centralizzato</p></li>
</ul>
<p>Nel seguente paragrafo vediamo gli algoritmi distribuiti di controllo della rete e poi nell’ultimo paragrafo vediamo gli
algoritmi centralizzati e come li ho implementato nel controller Ryu.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Topologia: &quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Topologia: 
</pre></div>
</div>
<img alt="../_images/analisi_dati_rete_BOBI_7_1.png" src="../_images/analisi_dati_rete_BOBI_7_1.png" />
</div>
</div>
<p>Questo è il modello della rete ad anello che uso per far vedere quali sono alcuni problemi che possono nascere.
Supponiamo il traffico entri nel nodo <span class="math notranslate nohighlight">\( i \)</span> e lasci la rete attraverso il nodo <span class="math notranslate nohighlight">\( [(i+1) mod n] +1 \)</span>. Indicando con <span class="math notranslate nohighlight">\( x_i \)</span>
il rate del traffico che il nodo <span class="math notranslate nohighlight">\( i \)</span> offre alla rete ed indicando <span class="math notranslate nohighlight">\( x_i' \)</span> il rate del traffico nel collegamento col
nodo successivo allora abbiamo:</p>
<p>\begin{equation}
\begin{cases}
x_i = min(x_i, \frac{c_i}{x_i+x_{i-1}’})\
x_i’’ = min(x_i’, \frac{c_{i+1}}{x_i’+x_{i+1}}x_i’)
\end{cases}<br />
\end{equation}</p>
<p>Per semplicità ipotizzimo <span class="math notranslate nohighlight">\( c_i = c \)</span> ed <span class="math notranslate nohighlight">\( x_i = x \quad \forall i \quad in \quad N \)</span>. A questo punto possiamo dire che
se <span class="math notranslate nohighlight">\( x \leq c/2 \)</span> allora non ci saranno perdite <span class="math notranslate nohighlight">\( x = x' = x'' \)</span> ed il throughput della rete sarà <span class="math notranslate nohighlight">\( nx \)</span>. <br>
Altrimenti si può dire che:
<br>  <span class="math notranslate nohighlight">\( x' = \frac{cx}{x+x'} \)</span> ed ottengo <span class="math notranslate nohighlight">\( x'=\frac{x}{2}(\sqrt{1+4\frac{c}{x}}-1) \)</span> <br>
ed inoltre sempre dalle equazioni precedenti so che
<br> <span class="math notranslate nohighlight">\( x'' = \frac{cx'}{x+x'} \)</span> ed ottengo <span class="math notranslate nohighlight">\( x''= c - \frac{x}{2}(\sqrt{1+4\frac{c}{x}} -1) \)</span> <br>
uso l’approssimazione di Taylor al primo ordine ed ottengo <span class="math notranslate nohighlight">\( x'' = \frac{c^2}{x} +o(\frac{1}{x}) \)</span> dove <span class="math notranslate nohighlight">\( o(\frac{1}{x}) \)</span>
denota tutti i termini di ordine superiore al secondo. Dunque si vede che <span class="math notranslate nohighlight">\( \lim_{x\to\infty} x''=0 \)</span> il rate dunque va
a zero ed anche il throughput andrà a zero, questo è il <em>congestion collapse</em>. Ogni device dovrà limitare la quantità di
traffico offerto alla rete, <em>ma come</em>?</p>
</div>
<div class="section" id="efficienza-ed-equita">
<h2>Efficienza ed equità<a class="headerlink" href="#efficienza-ed-equita" title="Permalink to this headline">¶</a></h2>
<p>Suppondendo che ci sia qualche meccanismo per il controllo del traffico e che quindi le perdite siano trascurabili si ha
che: <br> <span class="math notranslate nohighlight">\( x_n + x_i = c \quad \forall i \in [1 , n-1] \)</span> dunque il throughput
<span class="math notranslate nohighlight">\( \theta = (n-1)(c-x_n) + x_n = c(n-1) - x_n(n-2) \)</span> <br> Dunque una streategia per aumentare il thorughput è quella di
spingere il traffico offerto da <span class="math notranslate nohighlight">\( x_n \rightarrow 0 \)</span>, ma questo non è molto equo nei suoi confronti… C’è un altro modo
per garantire un uso completo delle risorse ed equo.</p>
</div>
<div class="section" id="allocazione-ottima-delle-risorse">
<h2>Allocazione ottima delle risorse<a class="headerlink" href="#allocazione-ottima-delle-risorse" title="Permalink to this headline">¶</a></h2>
<p>Per ottimizzare l’allocazione delle risorse di rete per tutti gli utenti, possiamo ragionare:</p>
<ul class="simple">
<li><p>in termini di ottimizzazione distribuita</p></li>
<li><p>dell’equilibrio di Nash in cui la rete si troverà a regime</p></li>
<li><p>secondo i principi di ottimalità di Wardrop</p></li>
</ul>
<p>Per l’analisi del problema delle ipotesi e della soluzione algoritmica si veda il seguente
<a class="reference external" href="https://github.com/andi-ra/Optimization/blob/main/notebooks/frank-wolfe.ipynb">notebook</a>.</p>
<p>A questo punto ragionando dell’ottimizzazione distribuita introduco la funzione ulitità <span class="math notranslate nohighlight">\( U_i(x_i) \)</span> che ogni device
produce per ogni info che trasmette. Ciò che voglio è massimizzare l’utilità dell’intero sistema. <br>
<span class="math notranslate nohighlight">\( \displaystyle\max_{x_i \ge 0}\sum_{i \in \overline{S}} U_i(x_i) \)</span>. Questo è molto diverso rispetto al concetto di
system optimum descritto da Wardrop.</p>
<div class="section" id="ipotesi-1">
<h3>Ipotesi 1<a class="headerlink" href="#ipotesi-1" title="Permalink to this headline">¶</a></h3>
<p>Per ogni <span class="math notranslate nohighlight">\( i \in \overline{S} \)</span>, <span class="math notranslate nohighlight">\( U_i(x_i) \)</span> è una funzione monotona crescente, liscia e convessa.</p>
<p>Sia <span class="math notranslate nohighlight">\( x_i^*, i \in \overline{S} \)</span> soluzione ottima del problema. Poiché per ipotesi la funzione è convessa e per le
proprietà del punto ottimo si ha che <span class="math notranslate nohighlight">\(\nabla U =0 \)</span> e quindi <br>
<span class="math notranslate nohighlight">\( \displaystyle\sum_{i \in \overline{S}} \nabla U_i(x_i^*)(x_i-x_i^*) \leq 0 \)</span> <br> da questo punto in poi ragiono con
un’analisi del punto fisso <span class="math notranslate nohighlight">\( x_i^* \)</span>. Riorganizzo i termini e posso dire: <br>
<span class="math notranslate nohighlight">\( \displaystyle\sum_{i \in \overline{S}} \nabla U_i(x_i^*)x_i^*\frac{x_i-x_i^*}{x_i^*} \leq 0 \)</span> <br> qual’è l’interpretazione
dei termini:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\( \frac{x_i-x_i^*}{x_i^*} \)</span> è il cambio marginale di rate di trasmissione della sorgente <span class="math notranslate nohighlight">\( i \)</span></p></li>
<li><p><span class="math notranslate nohighlight">\( \nabla U_i(x_i^*)x_i^* \)</span> può essere interpetato come la <em>fairness</em> della sorgente</p></li>
</ul>
<p>L’ultima equazione ci dice la somma pesata dei cambi di rate di trasmissione in ogni utente è meno di zero.</p>
</div>
<div class="section" id="proportional-fairness">
<h3>Proportional fairness<a class="headerlink" href="#proportional-fairness" title="Permalink to this headline">¶</a></h3>
<p>Scegliamo per esempio <span class="math notranslate nohighlight">\( U_i(x_i)=w_ilogx_i \)</span> con <span class="math notranslate nohighlight">\( w_i \ge 0 \)</span>. La disequazione variazionale diventa: <br>
<span class="math notranslate nohighlight">\( \displaystyle\sum_{i \in \overline{S}} w_i\frac{x_i-x_i^*}{x_i^*} \leq 0 \)</span>, dunque le variazioni di rate per ogni
utente pesati per la loro “importanza” sono non positivi.</p>
<div class="section" id="esempio">
<h4>Esempio<a class="headerlink" href="#esempio" title="Permalink to this headline">¶</a></h4>
<p>Sia data la rete in figura, chiamato anche <strong>modello KP</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/analisi_dati_rete_BOBI_9_0.png" src="../_images/analisi_dati_rete_BOBI_9_0.png" />
</div>
</div>
<p>Supponiamo di usare una allocazione <em>proporional fair</em> e cioè
<br> <span class="math notranslate nohighlight">\( U_i= w_ilogx_i \)</span> in cui <span class="math notranslate nohighlight">\( w_i=1 \)</span> <span class="math notranslate nohighlight">\(\forall i \in \overline{S}\)</span>  il problema diventa
<br><span class="math notranslate nohighlight">\(\displaystyle\max_{\textbf{x}\ge 0} \quad log x_0 +log x_1 + log x_2 \)</span> <br> <span class="math notranslate nohighlight">\(\qquad st \)</span> <br> <span class="math notranslate nohighlight">\(\qquad\)</span>
\begin{equation}
\begin{cases}
x_0 + x_1 \leq 2\
x_0 + x_2 \leq 1
\end{cases}<br />
\end{equation} <br>
Poiché il <span class="math notranslate nohighlight">\(\displaystyle \lim_{x\to 0} log x = -\infty \)</span> è chiaro che la politica di allocazione del traffico non potrà
asssegnare zero traffico ad un collegamento. Questo mi permette di considerare i vincoli <span class="math notranslate nohighlight">\( \textbf{x}\ge 0 \)</span> ridondanti.
Dunque volendo risolvere il problema tramite rilassamento lagrangiano posso rilassare i vincoli di capacità ottenendo:
<br> <span class="math notranslate nohighlight">\( \textbf{L}(\textbf{x}, \lambda) = \quad log x_0 +log x_1 + log x_2 -\lambda_A(x_0+x_1)-\lambda_B(x_0+x_2) \)</span> <br>
Ora cerco il punto stazionario ponendo <span class="math notranslate nohighlight">\( \frac{\partial L}{\partial x_i} =0 \)</span> <span class="math notranslate nohighlight">\( \forall i \in \overline{S} \)</span> ottengo:
<br> <span class="math notranslate nohighlight">\( x_0 = \frac{1}{\lambda_A+\lambda_B} \)</span> , <span class="math notranslate nohighlight">\( x_1 = \frac{1}{\lambda_A} \)</span> , <span class="math notranslate nohighlight">\( x_2 = \frac{1}{\lambda_B} \)</span> <br>
Questo unito al fatto che <span class="math notranslate nohighlight">\( x_0 + x_1 = 2\)</span> e <span class="math notranslate nohighlight">\(x_0 + x_2 = 1 \)</span> ottengo <br>  <span class="math notranslate nohighlight">\( \lambda_A = \frac{\sqrt{3}}{\sqrt{3}+1} \)</span> e
<span class="math notranslate nohighlight">\( \lambda_B = \sqrt{3} \)</span>
<br> dunque
\begin{equation}
\begin{cases}
x_0^* = \frac{\sqrt{3}+1}{2\sqrt{3}+3} \
x_1^* = \frac{\sqrt{3}+1}{\sqrt{3}} \
x_2^* = \frac{1}{\sqrt{3}}
\end{cases}<br />
\end{equation} <br></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="n">sns</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="s2">&quot;whitegrid&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;axes.grid&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">Axes3D</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>  <span class="c1"># Method 1</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_0$ variable&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_1$ variable&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_2$ variable&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C:\Users\DULLA\AppData\Local\Temp\ipykernel_28752\2092273623.py:10: MatplotlibDeprecationWarning: Axes3D(fig) adding itself to the figure is deprecated since 3.4. Pass the keyword argument auto_add_to_figure=False and use fig.add_axes(ax) to suppress this warning. The default value of auto_add_to_figure will change to False in mpl3.5 and True values will no longer work in 3.6.  This is consistent with other Axes classes.
  ax = Axes3D(fig)  # Method 1
</pre></div>
</div>
<img alt="../_images/analisi_dati_rete_BOBI_11_1.png" src="../_images/analisi_dati_rete_BOBI_11_1.png" />
</div>
</div>
<p>Qui verifico con Wolfram Mathematica che il procedimento sia corretto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>max{log(x) + log(y) + log(z)|x + y&lt;=1 ∧ x + z&lt;=2}≈-0.954769 at (x, y, z)≈(0.42265, 0.577351, 1.57735)
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="algoritmi-per-il-controllo-della-congestione">
<h2>Algoritmi per il controllo della congestione<a class="headerlink" href="#algoritmi-per-il-controllo-della-congestione" title="Permalink to this headline">¶</a></h2>
<p>Posso osservare che il problema definito precedentemente è un problema convesso e i vincoli di capacità sono dei vincoli
di simplesso. I vincoli di simplesso li ritroviamo anche nei problemi di ottimizzazione sparsa. Nei problemi di
ottimizzazione sparsa uno dei metodi principali per risolvere questi programmi è l’utilizzo del metodo a <em>penalty
function</em>. In pratica invece di considerare i vincoli di capacità come se fossero dei vincoli esterni, io li metto nella
funzione obiettivo attraverso l’uso di una funzione penalità. Se procedo in questo modo ottengo: <br>
<span class="math notranslate nohighlight">\(\displaystyle max_{x \ge 0} \sum_{i \in \overline{S}} U_i(x_i) - \sum_{l \in \overline{L}} \int_{0}^{\sum_{i \in S_l} x_i} p_l(x)\,dx \)</span></p>
<p>La funzione <span class="math notranslate nohighlight">\( p_l(x) \)</span> denota il <em>price</em> del collegamento, cioè il costo a cui vengo sottoposto per attraversare quel
collegamento e <span class="math notranslate nohighlight">\( c_l \)</span> è la sua capacità. Attenzione per i vincoli di conservazione in una rete di flusso a divergenza
nulla bisogna fare attenzione al fatto che il <em>price</em> del link <span class="math notranslate nohighlight">\( l \)</span> è funzione del tasso di arrivo <em>aggregato</em> cioè
faccio un taglio attorno al nodo e sommo su tutti i flussi che attraversano quel taglio.</p>
<p>Nel libro di <a class="reference external" href="https://dl.acm.org/doi/book/10.5555/984116">Srikant</a> l’autore dimostra come le condizioni necessarie di
ottimalità siano le seguenti: <span class="math notranslate nohighlight">\(\displaystyle U_i'(x_i) - \sum_{l \in L_i}p_l(\sum_{r \in S_l}x_r) = 0 \)</span>,
<span class="math notranslate nohighlight">\(i\in \overline{S} \)</span> Dunque posso creare un algoritmo di controllo con un metodo del gradiente, ottenendo: <br>
<span class="math notranslate nohighlight">\(\displaystyle \frac{dx_r}{dt} = k_i(x_i)(U_i'(x_i) - \sum_{l \in L_i}p_l(\sum_{r \in S_l}x_r))_{x_i}^{+} \)</span> ,
<span class="math notranslate nohighlight">\(i\in \overline{S} \)</span> il simbolo <span class="math notranslate nohighlight">\( [ \circ ]^{+} \)</span> indica la parte positiva, dunque useremo un gradiente proiettato. Questo
algoritmo sempre nel libro di <a class="reference external" href="https://dl.acm.org/doi/book/10.5555/984116">Srikant</a> viene dimostrato come l’obiettivo sia
una funzione di Lyapunov per il sistema, dunque qualunque traiettoria venga indicata dalla soluzione del mio controllore
sarà asintoticamente stabile. Una verisione semplificata ed implementata di questo controllore è l’algoritmo di
<a class="reference external" href="http://www.statslab.cam.ac.uk/~frank/rate.pdf">Kelly</a>.</p>
<p>Si può ragionare in modo analogo anche con il problema duale. In questa versione ogni collegamento usa il proprio tasso
di arrivo totale e con quello si calcola il prezzo di sé stesso. Questo algoritmo si può intereptare nel seguente modo:
se il tasso totale di arrivi è superiore alla propria capacità, allora incrementa il proprio prezzo secondo una <em>barrier</em>
function opportuna, altrimenti decrementa il prezzo. Perché parlare di algoritmi di ottimizzazione duali e primali nel
contesto delle reti? Perché è giusto capire con che logica funzionano gli algoritmi ad oggi usati per la gestione delle
congestioni e del flusso. In modo approssimato si possono classificare in 2 categorie:</p>
<ul class="simple">
<li><p>A livello di trasporto come nel TCP NewReno oppure Vegas i quali basano il traffico offerto su dei feedback disponibili</p></li>
<li><p>A livello di rete attraverso meccanismi impliciti come AQM DropTail o RED</p></li>
</ul>
<p>In prima approssimazione possiamo dire come l’algoritmo primale ha una legge dinamica per gestire il tasso di invio dalla
sorgente ed una legge statica per generare il prezzo del collegamento, un po’ come in TCP. Dall’altra parte possiamo dire
che il problema duale usa una legge statica per gestire il tasso di invio della sorgente ed una legge dinamica
(tempovariante) per assegnare il <em>price</em> al collegamento, similmente a come lavora AQM. Giusto per fare un esempio: nei
meccanismi di AQM il prezzo ombra (il <em>price</em>) è il <span class="math notranslate nohighlight">\( p_l \)</span> e nel metodo di Floyd e Jacobson la lunghezza della coda viene
usata come stimatore del tasso di congestione del collegamento. In quel caso uso la versione duale dell’algoritmo per
aggiustae il prezzo del collegamento.</p>
<p>Il problema di questi metodi è che sono computazionalmente molto dispensiosi, questo a causa del calcolo all’interno
dell’algoritmo (vedi <em>steepset descent</em> nel metodo primale) oppure per il calcolo di uno stimatore per la congestione in
un collegamento (vedi lo stimatore empirico lunghezza del buffer nel AQM).</p>
</div>
<div class="section" id="algoritmi-centralizzati-metodi-sdn">
<h2>Algoritmi centralizzati: metodi SDN<a class="headerlink" href="#algoritmi-centralizzati-metodi-sdn" title="Permalink to this headline">¶</a></h2>
<p>Adesso ci concentriamo su gli algoritmi centralizzati. Questi metodi possono essere di due tipi:</p>
<ul class="simple">
<li><p>Centralizzati eseguiti su ogni device (ad esempio Djikstra con OSPF) ogni device manda in flooding <em>tutto</em></p></li>
<li><p>Centralizzati su un unico device, oggetto di questo paragrafo</p></li>
</ul>
<p>Un’ultima postilla che faccio sul primo punto è la seguente osservazione: l’algoritmo OSPF con Djikstra è un ottimo
algoritmo di label correcting. Ha una debolezza: ogni device ha bisogno dell’<em>intera</em> topologia e quindi ogni device
deve trasmettere un LSA (link state advertisement) in ogni singolo collegamento non bloccato con STP. Ho quindi un numero
di pacchetti che nel peggiore dei casi sarà <span class="math notranslate nohighlight">\( o(n^2) \)</span>. Dunque OSPF è il miglior algoritmo che abbiamo a disposizione ma
è molto pesante…</p>
<p>Nel caso degli algoritmi centralizzati in questo documento essi vengono eseguiti tutti</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="stable.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Distribuzioni stabili</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="main_pipeline.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Albero ricoprente di costo minimo capacitato</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Andi Dulla<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>